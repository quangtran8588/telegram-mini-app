function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = ["assets/index-DkV6lUaB.js","assets/index-DiwrgTda.css","assets/read-contract-FiM0lQSn.js","assets/hashMessage-BGN9q6Kk.js","assets/checkContractWalletSignature-PZMWcIl9.js"]
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
import{B as Z,t as V,r as ee,v as te,w as O,A as ne,x as U,y as N,z as ae,C as re,D as se,E as ie,F as j,G as W,H as k,I as oe,P as ce,J as E,K as ue,L as de,M as z,n as pe,c as fe,N as le,O as me,Q as J,R as g,s as K,S as T,T as ye,U as Y,V as he,W as ge,X as C,Y as Ae,Z as w,$ as I,_ as A,a0 as M}from"./index-DkV6lUaB.js";import{readContract as ve}from"./read-contract-FiM0lQSn.js";class we extends Z{constructor(e){super(`Filter type "${e}" is not supported.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"FilterTypeNotSupportedError"})}}const _=V;function be(t){const{abi:e,args:n=[],name:r}=t,a=ee(r,{strict:!1}),i=e.filter(u=>a?u.type==="function"?te(u)===r:u.type==="event"?_(u)===r:!1:"name"in u&&u.name===r);if(i.length===0)return;if(i.length===1)return i[0];let s;for(const u of i){if(!("inputs"in u))continue;if(!n||n.length===0){if(!u.inputs||u.inputs.length===0)return u;continue}if(!u.inputs||u.inputs.length===0||u.inputs.length!==n.length)continue;if(n.every((c,f)=>{const l="inputs"in u&&u.inputs[f];return l?P(c,l):!1})){if(s&&"inputs"in s&&s.inputs){const c=q(u.inputs,s.inputs,n);if(c)throw new ne({abiItem:u,type:c[0]},{abiItem:s,type:c[1]})}s=u}}return s||i[0]}function P(t,e){const n=typeof t,r=e.type;switch(r){case"address":return O(t,{strict:!1});case"bool":return n==="boolean";case"function":return n==="string";case"string":return n==="string";default:return r==="tuple"&&"components"in e?Object.values(e.components).every((a,i)=>P(Object.values(t)[i],a)):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(r)?n==="number"||n==="bigint":/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r)?n==="string"||t instanceof Uint8Array:/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r)?Array.isArray(t)&&t.every(a=>P(a,{...e,type:r.replace(/(\[[0-9]{0,}\])$/,"")})):!1}}function q(t,e,n){for(const r in t){const a=t[r],i=e[r];if(a.type==="tuple"&&i.type==="tuple"&&"components"in a&&"components"in i)return q(a.components,i.components,n[r]);const s=[a.type,i.type];if(s.includes("address")&&s.includes("bytes20")?!0:s.includes("address")&&s.includes("string")?O(n[r],{strict:!1}):s.includes("address")&&s.includes("bytes")?O(n[r],{strict:!1}):!1)return s}}const S="/docs/contract/encodeEventTopics";function xe(t){var d;const{abi:e,eventName:n,args:r}=t;let a=e[0];if(n){const c=be({abi:e,name:n});if(!c)throw new U(n,{docsPath:S});a=c}if(a.type!=="event")throw new U(void 0,{docsPath:S});const i=N(a),s=_(i);let u=[];if(r&&"inputs"in a){const c=(d=a.inputs)==null?void 0:d.filter(l=>"indexed"in l&&l.indexed),f=Array.isArray(r)?r:Object.values(r).length>0?(c==null?void 0:c.map(l=>r[l.name]))??[]:[];f.length>0&&(u=(c==null?void 0:c.map((l,p)=>Array.isArray(f[p])?f[p].map((h,y)=>R({param:l,value:f[p][y]})):f[p]?R({param:l,value:f[p]}):null))??[])}return[s,...u]}function R({param:t,value:e}){if(t.type==="string"||t.type==="bytes")return ae(re(e));if(t.type==="tuple"||t.type.match(/^(.*)\[(\d+)?\]$/))throw new we(t.type);return se([t],[e])}const F="/docs/contract/decodeEventLog";function Ge(t){const{abi:e,data:n,strict:r,topics:a}=t,i=r??!0,[s,...u]=a;if(!s)throw new ie({docsPath:F});const d=e.find(o=>o.type==="event"&&s===_(N(o)));if(!(d&&"name"in d)||d.type!=="event")throw new j(s,{docsPath:F});const{name:c,inputs:f}=d,l=f==null?void 0:f.some(o=>!("name"in o&&o.name));let p=l?[]:{};const h=f.filter(o=>"indexed"in o&&o.indexed);for(let o=0;o<h.length;o++){const m=h[o],v=u[o];if(!v)throw new W({abiItem:d,param:m});p[m.name||o]=Oe({param:m,value:v})}const y=f.filter(o=>!("indexed"in o&&o.indexed));if(y.length>0){if(n&&n!=="0x")try{const o=k(y,n);if(o)if(l)p=[...p,...o];else for(let m=0;m<y.length;m++)p[y[m].name]=o[m]}catch(o){if(i)throw o instanceof oe||o instanceof ce?new E({abiItem:d,data:n,params:y,size:ue(n)}):o}else if(i)throw new E({abiItem:d,data:"0x",params:y,size:0})}return{eventName:c,args:Object.values(p).length>0?p:void 0}}function Oe({param:t,value:e}){return t.type==="string"||t.type==="bytes"||t.type==="tuple"||t.type.match(/^(.*)\[(\d+)?\]$/)?e:(k([t],e)||[])[0]}function Ee({abi:t,eventName:e,logs:n,strict:r=!0}){return n.map(a=>{var i;try{const s=Ge({...a,abi:t,strict:r});return e&&!e.includes(s.eventName)?null:{...s,...a}}catch(s){let u,d;if(s instanceof j)return null;if(s instanceof E||s instanceof W){if(r)return null;u=s.abiItem.name,d=(i=s.abiItem.inputs)==null?void 0:i.some(c=>!("name"in c&&c.name))}return{...a,args:d?[]:{},eventName:u}}}).filter(Boolean)}function Pe(t){return!!(t&&typeof t=="object"&&"type"in t&&t.type==="event")}function De(t){const{signature:e}=t;let n;return Pe(e)?n=e:n=de(e),{abiEvent:n,hash:V(n),topics:xe({abi:[n],args:t.filters})}}function Te(t){const{logs:e,events:n,strict:r}=t;return Ee({logs:e,abi:n.map(a=>a.abiEvent),strict:r})}function _e(t={}){return De({signature:"event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)",filters:t})}const Le="0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c",b="0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",Ue=50000n,Q=t=>`https://${t.id}.bundler.thirdweb.com/`,Ce=t=>`https://${t.id}.bundler.thirdweb.com/`,Ie=()=>{const t=BigInt(Math.floor(Math.random()*4294967296)),e=BigInt(Math.floor(Math.random()*4294967296)),n=BigInt(Math.floor(Math.random()*4294967296)),r=BigInt(Math.floor(Math.random()*4294967296)),a=BigInt(Math.floor(Math.random()*4294967296)),i=BigInt(Math.floor(Math.random()*4294967296));return t<<BigInt(160)|e<<BigInt(128)|n<<BigInt(96)|r<<BigInt(64)|a<<BigInt(32)|i},Me=()=>BigInt(z([pe(Ie()),"0x0000000000000000"]));function L(t){return Object.fromEntries(Object.entries(t).map(([e,n])=>[e,fe(n)?n:le(n)]))}async function Se(t){var e;return x({...t,operation:"eth_sendUserOperation",params:[L(t.userOp),((e=t.options.overrides)==null?void 0:e.entrypointAddress)??b]})}async function B(t){var n;const e=await x({...t,operation:"eth_estimateUserOperationGas",params:[L(t.userOp),((n=t.options.overrides)==null?void 0:n.entrypointAddress)??b]});return{preVerificationGas:g(e.preVerificationGas),verificationGas:g(e.verificationGas),verificationGasLimit:g(e.verificationGasLimit),callGasLimit:g(e.callGasLimit)+Ue}}async function Re(t){const e=await x({...t,operation:"thirdweb_getUserOperationGasPrice",params:[]});return{maxPriorityFeePerGas:g(e.maxPriorityFeePerGas),maxFeePerGas:g(e.maxFeePerGas)}}async function Fe(t){var n,r;const e=await x({...t,operation:"eth_getUserOperationReceipt",params:[t.userOpHash]});if(e){if(e.success===!1){const i=(r=(n=Te({events:[_e()],logs:e.logs})[0])==null?void 0:n.args)==null?void 0:r.revertReason;if(!i)throw new Error(`UserOp failed at txHash: ${e.transactionHash}`);const s=me({data:i});throw new Error(`UserOp failed with reason: '${s.args.join(",")}' at txHash: ${e.transactionHash}`)}return e.receipt}}async function x(t){var d;const{options:e,operation:n,params:r}=t,a=((d=e.overrides)==null?void 0:d.bundlerUrl)??Q(e.chain),s=await J(e.client)(a,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",id:1,method:n,params:r})}),u=await s.json();if(!s.ok||u.error){let c=u.error||s.statusText;typeof c=="object"&&(c=JSON.stringify(c));const f=u.code||"UNKNOWN";throw new Error(`${n} error: ${c}
Status: ${s.status}
Code: ${f}`)}return u.result}async function Be(t,e){var a,i,s;if((a=e.overrides)!=null&&a.predictAddress)return e.overrides.predictAddress(t);const n=((i=e.overrides)==null?void 0:i.accountAddress)||e.personalAccountAddress;if(!n)throw new Error("Account address is required to predict the smart wallet address.");const r=K(((s=e.overrides)==null?void 0:s.accountSalt)??"");return ve({contract:t,method:"function getAddress(address, bytes) returns (address)",params:[n,r]})}function $e(t){var r,a,i;const{factoryContract:e,options:n}=t;return(r=n.overrides)!=null&&r.createAccount?n.overrides.createAccount(e):T({contract:e,method:"function createAccount(address, bytes) returns (address)",params:[((a=n.overrides)==null?void 0:a.accountAddress)||n.personalAccount.address,K(((i=n.overrides)==null?void 0:i.accountSalt)??"")]})}function He(t){var a;const{accountContract:e,options:n,transaction:r}=t;return(a=n.overrides)!=null&&a.execute?n.overrides.execute(e,r):T({contract:e,method:"function execute(address, uint256, bytes)",params:[r.to||"",r.value||0n,r.data||"0x"]})}function Ve(t){var a;const{accountContract:e,options:n,transactions:r}=t;return(a=n.overrides)!=null&&a.executeBatch?n.overrides.executeBatch(e,r):T({contract:e,method:"function executeBatch(address[], uint256[], bytes[])",params:[r.map(i=>i.to||""),r.map(i=>i.value||0n),r.map(i=>i.data||"0x")]})}async function $(t){var l,p,h,y;const{userOp:e,options:n}=t;if((l=n.overrides)!=null&&l.paymaster)return(p=n.overrides)==null?void 0:p.paymaster(e);const r={"Content-Type":"application/json"},a=n.client,i=Ce(n.chain),s=((h=n.overrides)==null?void 0:h.entrypointAddress)??b,d=await J(a)(i,{method:"POST",headers:r,body:JSON.stringify({jsonrpc:"2.0",id:1,method:"pm_sponsorUserOperation",params:[L(e),s]})}),c=await d.json();if(!d.ok){const o=c.error||d.statusText,m=c.code||"UNKNOWN";throw new Error(`Paymaster error: ${o}
Status: ${d.status}
Code: ${m}`)}if(c.result)return typeof c.result=="string"?{paymasterAndData:c.result}:{paymasterAndData:c.result.paymasterAndData,verificationGasLimit:c.result.verificationGasLimit?g(c.result.verificationGasLimit):void 0,preVerificationGas:c.result.preVerificationGas?g(c.result.preVerificationGas):void 0,callGasLimit:c.result.callGasLimit?g(c.result.callGasLimit):void 0};const f=((y=c.error)==null?void 0:y.message)||c.error||d.statusText||"unknown error";throw new Error(`Paymaster error from ${i}: ${f}`)}async function Ne(t){var y;const{factoryContract:e,accountContract:n,executeTx:r,options:a}=t,s=await ye(n)?"0x":await We({factoryContract:e,options:a}),u=await Y(r);let{maxFeePerGas:d,maxPriorityFeePerGas:c}=r;const f=((y=a.overrides)==null?void 0:y.bundlerUrl)??Q(a.chain);if(he(f)){const o=await Re({options:a});d=o.maxFeePerGas,c=o.maxPriorityFeePerGas}else if(!d||!c){const o=await ge(e.client,e.chain);c||(c=o.maxPriorityFeePerGas??void 0),d||(d=o.maxFeePerGas??void 0)}const l=Me(),p={sender:n.address,nonce:l,initCode:s,callData:u,maxFeePerGas:await C(d)??0n,maxPriorityFeePerGas:await C(c)??0n,callGasLimit:0n,verificationGasLimit:0n,preVerificationGas:0n,paymasterAndData:"0x",signature:Le};if(a.gasless){const o=await $({userOp:p,options:a}),m=o.paymasterAndData;if(m&&m!=="0x"&&(p.paymasterAndData=m),o.callGasLimit&&o.verificationGasLimit&&o.preVerificationGas)p.callGasLimit=o.callGasLimit,p.verificationGasLimit=o.verificationGasLimit,p.preVerificationGas=o.preVerificationGas;else{const v=await B({userOp:p,options:a});if(p.callGasLimit=v.callGasLimit,p.verificationGasLimit=v.verificationGasLimit,p.preVerificationGas=v.preVerificationGas,m&&m!=="0x"){const G=await $({userOp:p,options:a});G.paymasterAndData&&G.paymasterAndData!=="0x"&&(p.paymasterAndData=G.paymasterAndData)}}}else{const o=await B({userOp:p,options:a});p.callGasLimit=o.callGasLimit,p.verificationGasLimit=o.verificationGasLimit,p.preVerificationGas=o.preVerificationGas}return{...p,signature:"0x"}}async function je(t){var a;const{userOp:e,options:n}=t,r=ke({userOp:e,entryPoint:((a=n.overrides)==null?void 0:a.entrypointAddress)||b,chainId:n.chain.id});if(n.personalAccount.signMessage){const i=await n.personalAccount.signMessage({message:{raw:Ae(r)}});return{...e,signature:i}}throw new Error("signMessage not implemented in signingAccount")}async function We(t){const{factoryContract:e,options:n}=t,r=$e({factoryContract:e,options:n});return z([e.address,await Y(r)])}function ke(t){const{userOp:e,entryPoint:n,chainId:r}=t,a=w(e.initCode),i=w(e.callData),s=w(e.paymasterAndData),u=I([{type:"address"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"},{type:"uint256"},{type:"uint256"},{type:"uint256"},{type:"uint256"},{type:"uint256"},{type:"bytes32"}],[e.sender,e.nonce,a,i,e.callGasLimit,e.verificationGasLimit,e.preVerificationGas,e.maxFeePerGas,e.maxPriorityFeePerGas,s]),d=I([{type:"bytes32"},{type:"address"},{type:"uint256"}],[w(u),n,BigInt(r)]);return w(d)}const X=new WeakMap,D=new WeakMap;async function Qe(t,e,n){const{personalAccount:r,client:a,chain:i}=e;if(!r)throw new Error("Personal wallet does not have an account");const s=n,u=i??s.chain,d=s.factoryAddress,c=M({client:a,address:d,chain:u}),f=await Be(c,{personalAccountAddress:r.address,...s}),l=M({client:a,address:f,chain:u}),p=await ze({...s,personalAccount:r,accountContract:l,factoryContract:c,client:a});return X.set(r,t),D.set(t,r),[p,u]}async function Xe(t){const e=D.get(t);e&&(X.delete(e),D.delete(t))}async function ze(t){const{accountContract:e,factoryContract:n}=t,r={address:e.address,async sendTransaction(a){const i=He({accountContract:e,options:t,transaction:a});return H({factoryContract:n,accountContract:e,executeTx:i,options:t})},async sendBatchTransaction(a){const i=Ve({accountContract:e,options:t,transactions:a});return H({factoryContract:n,accountContract:e,executeTx:i,options:t})},async signMessage({message:a}){const[{isContractDeployed:i},{readContract:s},{encodeAbiParameters:u},{hashMessage:d},{checkContractWalletSignature:c}]=await Promise.all([A(()=>import("./index-DkV6lUaB.js").then(o=>o.a_),__vite__mapDeps([0,1])),A(()=>import("./read-contract-FiM0lQSn.js"),__vite__mapDeps([2,0,1])),A(()=>import("./index-DkV6lUaB.js").then(o=>o.b0),__vite__mapDeps([0,1])),A(()=>import("./hashMessage-BGN9q6Kk.js"),__vite__mapDeps([3,0,1])),A(()=>import("./checkContractWalletSignature-PZMWcIl9.js"),__vite__mapDeps([4,2,0,1]))]);await i(e)||(console.log("Account contract not deployed yet. Deploying account before signing message"),await Je({options:t,account:r,accountContract:e}));const l=d(a);let p=!1;try{await s({contract:e,method:"function getMessageHash(bytes32 _hash) public view returns (bytes32)",params:[l]}),p=!0}catch{}let h;if(p){const o=u([{type:"bytes32"}],[l]);h=await t.personalAccount.signTypedData({domain:{name:"Account",version:"1",chainId:t.chain.id,verifyingContract:e.address},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]},message:{message:o}})}else h=await t.personalAccount.signMessage({message:a});if(await c({contract:e,message:a,signature:h}))return h;throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.")},async signTypedData(a){return t.personalAccount.signTypedData(a)},async estimateGas(a){return 0n}};return r}async function Je(t){const{options:e,account:n,accountContract:r}=t,[{sendTransaction:a},{prepareTransaction:i}]=await Promise.all([A(()=>import("./index-DkV6lUaB.js").then(d=>d.b2),__vite__mapDeps([0,1])),A(()=>import("./index-DkV6lUaB.js").then(d=>d.b1),__vite__mapDeps([0,1]))]),s=i({client:e.client,chain:e.chain,to:r.address,value:0n});return await a({transaction:s,account:n})}async function H(t){const{factoryContract:e,accountContract:n,executeTx:r,options:a}=t,i=await Ne({factoryContract:e,accountContract:n,executeTx:r,options:a}),s=await je({options:a,userOp:i}),u=await Se({options:a,userOp:s}),d=await Ke({options:a,userOpHash:u});return{client:a.client,chain:a.chain,transactionHash:d.transactionHash}}async function Ke(t){const{options:e,userOpHash:n}=t,r=3e4,a=1e3,i=Date.now()+r;for(;Date.now()<i;){const s=await Fe({options:e,userOpHash:n});if(s)return s;await new Promise(u=>setTimeout(u,a))}throw new Error("Timeout waiting for userOp to be mined")}export{Qe as connectSmartWallet,Xe as disconnectSmartWallet,X as personalAccountToSmartAccountMap};
